---
layout: post
title: "Day 8 - Studying code"
categories: [til, python, SQL]
---

# Day 8 ‚Äî Python & SQL
üìÖ 2026-01-13

Today is **Day 8 of my  learning journey**.  

This post is written mainly for myself, but it may also help other beginners.

---

## Python String Validation Methods
### str.isdigit()
Returns True if all characters are digits (0‚Äì9) and the string is not empty
‚ùå No letters, spaces, signs, or decimals allowed
```python
"123".isdigit()      # True
"12a".isdigit()      # False
"12 3".isdigit()     # False
"-123".isdigit()     # False
```

### str.isalpha()
Returns True if all characters are alphabet letters
‚ùå No numbers, spaces, or symbols
```python
"hello".isalpha()    # True
"hello1".isalpha()   # False
"hello world".isalpha()  # False
```

### str.isalnum()
Returns True if all characters are letters or digits
‚ùå No spaces or special characters
```python
"abc123".isalnum()   # True
"abc 123".isalnum()  # False
```

### str.islower()
Returns True if all letters are lowercase
Numbers/symbols are ignored
At least one letter must exist
```python
"hello".islower()    # True
"hello123".islower() # True
"Hello".islower()    # False
```

### str.isupper()
Returns True if all letters are uppercase
Numbers/symbols are ignored
At least one letter must exist
```python
"HELLO".isupper()    # True
"HELLO123".isupper() # True
"Hello".isupper()    # False
```

### str.isspace()
Returns True if the string contains only whitespace
```python
"   ".isspace()      # True
"\n\t".isspace()     # True
" a ".isspace()      # False
```

### str.isdecimal()
Stricter version of isdigit()
Only standard decimal digits (0‚Äì9)
```python
"123".isdecimal()    # True
"¬≤".isdecimal()      # False
```

## Python memory and references
Variable names don‚Äôt store values ‚Äî they store references (arrows) to objects in memory.
### Assignment (=)
Assignment means rebinding a name to an object.
Examples:
```python
x = [1, 2, 3]
x = [4, 5, 6]
```
Creates a new object
Moves the reference
Does NOT affect other references
'=' is always assignment, never mutation

### Mutation (in-place change)
Mutation means changing the contents of an existing object.
Examples:
```python
x[0] = 99
x.append(4)
x[:] = [0, 1, 2]
```
Object stays the same
Contents change
All references see the change

### Mutable vs Immutable types
#### Mutable (can be mutated)
list
dict
set
bytearray
numpy.ndarray

#### Immutable (cannot be mutated)
int
float
str
tuple
frozenset

### Functions and arguments
Function parameters are assigned references
Mutating the object affects the caller
Rebinding the parameter does NOT
```python
def f(x):
    x = [1, 2, 3]
# does not change caller
def f(x):
    x[0] = 99
# does change caller
```
Returning alone does nothing
Caller must reassign

### Slice assignment
If you just slice without replace value it will not mutate. new object created
If you slice with replace value will mutate. Same object mutated
```python
a = nums[1:3]
# No mutation, creates new object
nums[1:3] = [9, 9]
nums[:] = [0, 1, 2]
# Mutation, same object mutated
```

## Python In-Place (Mutating) Operations
### List (mutable)
All of the following modify the list **in place**:
- `lst.append(x)`
- `lst.extend(iterable)`
- `lst.insert(i, x)`
- `lst.remove(x)`
- `lst.pop(i)`
- `lst.clear()`
- `lst.sort()`
- `lst.reverse()`
- `lst[:] = [0, 1, 2]`  <!-- slice assignment -->
Notes:
- These methods return `None`
- `sorted(lst)` does **not** mutate (returns a new list)

---

### Dictionary (mutable)
All of the following modify the dictionary **in place**:
- `d[key] = value`
- `d.update(other)`
- `d.pop(key)`
- `d.popitem()`
- `d.clear()`

---

### Set (mutable)
All of the following modify the set **in place**:
- `s.add(x)`
- `s.remove(x)`
- `s.discard(x)`
- `s.pop()`
- `s.update(other)`
- `s.clear()`

---

### NumPy Array (mutable)
The following modify the array **in place**:
- `arr += 1`
- `arr.sort()`
- `arr.fill(0)`
Note:
- `+=` is in-place for NumPy arrays, but **not** for Python integers

---
### Key Rules

- Assignment (`=`) moves references ‚Äî it is **never mutation**
- Mutation changes the object itself
- All references to a mutated object see the change
- Slice assignment mutates; slicing alone does not

---


## SQL Window Frames
When you need a rolling/ moving calculation (like ‚Äúlast 7 days including today‚Äù), GROUP BY alone can‚Äôt do it. A window function lets you compute aggregates per row while still seeing neighboring rows.
Window definition: OVER (...)
Frame definition: ROWS BETWEEN ... AND ... (optional but powerful)
```python
SUM(daily_amount) OVER (
  ORDER BY visited_on
  ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
)
```


